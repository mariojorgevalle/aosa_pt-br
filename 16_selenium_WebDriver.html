<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.2  (Unix)">
	<META NAME="CREATED" CONTENT="0;0">
	<META NAME="CHANGEDBY" CONTENT="Weslleymberg Lisboa">
	<META NAME="CHANGED" CONTENT="20110809;15282500">
	<META NAME="CHANGEDBY" CONTENT="Weslleymberg Lisboa">
	<META NAME="CHANGEDBY" CONTENT="Weslleymberg Lisboa">
	<META NAME="CHANGEDBY" CONTENT="Weslleymberg Lisboa">
	<META NAME="CHANGEDBY" CONTENT="Weslleymberg Lisboa">
	<META NAME="CHANGEDBY" CONTENT="Weslleymberg Lisboa">
	<META NAME="CHANGEDBY" CONTENT="Weslleymberg Lisboa">
	<META NAME="CHANGEDBY" CONTENT="weslleymberg ">
	<META NAME="CHANGEDBY" CONTENT="weslleymberg ">
	<META NAME="CHANGEDBY" CONTENT="weslleymberg ">
	<META NAME="CHANGEDBY" CONTENT="weslleymberg ">
	<META NAME="SDFOOTNOTE" CONTENT=";;;;P">
	<STYLE TYPE="text/css">
	<!--
		@page { margin: 2cm }
		P { margin-bottom: 0.21cm; color: #000000; font-family: "Times New Roman", serif; font-size: 12pt; font-style: normal; font-weight: normal; line-height: 100%; text-align: left; widows: 2; orphans: 2; text-decoration: none; page-break-before: auto; page-break-after: auto }
	-->
	</STYLE>
</HEAD>
<BODY LANG="pt-BR" TEXT="#000000" DIR="LTR">
<P ALIGN=LEFT STYLE="margin-bottom: 0cm; font-style: normal; font-weight: normal; line-height: 100%; widows: 2; orphans: 2; text-decoration: none; page-break-before: auto; page-break-after: auto">
<SPAN STYLE="background: transparent"><FONT FACE="Times New Roman"><FONT SIZE=3>Tradução
CAP 16 <BR><BR>Capítulo 16 - Selenium WebDriver <BR><BR>Simon
Stewart <BR><BR>Selenium é uma ferramenta para automação de
navegadores, comumente usada para escrever testes de aplicações web
de ponta-a-ponta. Uma ferramenta de automação de navegadores faz o
exatamente o que você esperaria: automatiza o controle de um
navegador, sendo assim, tarefas repetitivas podem ser automatizadas.
Isto parece um simples problema a ser resolvido, mas como veremos,
muitas coisas têm que acontecer debaixo dos panos para que tudo
funcione. <BR><BR>Antes de descrever a arquitetura do Selenium é
necessário entender como as várias partes do projeto se encaixam.
<U>Por cima</U>, Selenium é uma coleção de três ferramentas. A
primeira destas, Selenium IDE, é uma extensão para Firefox que
permite aos usuários gravar e refazer testes. O paradigma
gravar/refazer pode ser limitado e não adaptável para muitos
usuários, então a segunda ferramenta da coleção, Selenium
WebDriver, provê APIs em várias linguagens para permitir um maior
controle e aplicação de praticas de desenvolvimento de software
padrão. A última ferramenta, Selenium Grid, torna possível o uso
das APIs do Selenium para controlar instâncias de navegadores
distribuídas sobre um rede de máquinas, permitindo executar mais
testes paralelamente. No interior do projeto, eles são referenciados
como &quot;IDE&quot;, &quot;WebDriver&quot; e &quot;Grid&quot;. Este
capítulo explora a arquitetura do Selenium WebDriver. <BR><BR>Este
capítulo foi escrito durante os betas do Selenium 2.0 no final de
2010. Se você está lendo o livro após o fim de 2010, então as
coisas já terão avançado, e você será capaz de ver como as
escolhas arquiteturais descritas aqui se desdobraram. Se você está
lendo antes do fim de 2010: Parabéns! Você tem uma máquina do
tempo. Pode me dar os números vencedores da loteria? <BR><BR>16.1.
História <BR><BR>Jason Huggins começou o projeto Selenium em 2004
enquanto trabalhava no ThoughtWorks do sistema feito por eles, Time
and Expenses (T&amp;E), que fez amplo uso de Javascript. Embora o
Internet Explorer fosse o navegador dominante na época, ThoughtWorks
usou vários navegadores alternativos (em particular, as variações
do Mozzila) e enviava um relatório de erro quando o aplicativo T&amp;E
não funcionava no navegador escolhido. Ferramentas de testes naquela
época, ou eram focadas em um único navegador (normalmente IE) ou
eram simulações de um navegador (como HttpUnit). O custo de uma
licença para uma ferramenta comercial teria esgotado o orçamento
limitado de um pequeno projeto interno, então eles nem mesmo
consideraram como uma alternativa viável. <BR><BR>Onde a automação
de testes se torna difícil, é comum recorrer à testes manuais.
Está abordagem não funciona quando a equipe é muito pequena ou
quando a liberação de novas versões é extremamente frequente. É
também uma falta de humanidade, pedir a uma pessoa que revise um
<U>código</U> que poderia ser automatizado. Comumente, pessoas são
mais lentas e mais susceptíveis à erros em tarefas repetitivas do
que máquinas. Teste manual não era um opção.<BR><BR>Felizmente,
todos os navegadores que foram testados <U>suportavam</U> Javascript.
Escrever um ferramenta de teste nesta linguagem, fez sentido para
Jason e a equipe com a qual ele trabalhava, pois esta poderia ser
usada para verificar o comportamento da aplicação. Inspirado pelo
trabalho feito no <U>FIT¹</U>, uma sintaxe baseada em tabelas
(<U>table-based</U>)<FONT COLOR="#0000ff"> </FONT>foi colocada sobre
o Javascript puro e isso permitiu que os testes fossem escritos por
pessoas com experiência limitada em programação usando uma
abordagem baseada em palavras chave (<U>keyword-based</U>) em
arquivos HTML. Esta ferramenta, originalmente chamada de “Selenium”
mas depois referenciada como “Selenium Core”, foi liberada em
2004 sob a licença Apache 2.<BR><BR>A formatação em tabelas do
Selenium é estruturada similarmente ao <U>ActionFixture presente</U>
no FIT. Cada linha da tabela é dividida em três colunas. A primeira
coluna contém o nome do comando a ser executado, a segunda coluna
tipicamente contém um elemento identificador e a terceira coluna
contém um valor opcional. Por exemplo, isto é como definir a string
“Selenium WebDriver” dentro de um elemento identificado pelo nome
“q”:<BR><BR>type &nbsp;&nbsp;&nbsp;&nbsp;name=q &nbsp;&nbsp;&nbsp;Selenium
WebDriver<BR><BR><BR>Pelo fato do Selenium ter sido escrito em
Javascript <U>puro</U>, seu design inicial requeria que os
desenvolvedores hospedassem o <U>Core</U> e seus testes no mesmo
servidor em que estava a aplicação a ser testada (AUT) para evitar
falhas grosseiras das politicas de segurança do navegador e do
Javascript <U>sandbox</U>. Isso nem sempre era prático ou possível.
E pior, ainda que a IDE dos desenvolvedores lhes desse habilidade
para rapidamente manipular o código e navegar pela extensa coleção
de códigos-fonte (codebade), não existe tal ferramenta para HTML.
Rapidamente se tornou claro que manter uma coleção de testes pela
metade era um <U>propósito</U> incômodo e doloroso.<BR><BR>Para
resolver este e outros problemas, um proxy HTTP foi escrito para que
toda solicitação HTTP pudesse ser interceptada pelo Selenium.
Usando este proxy, tornou-se possível desviar de muitas das
limitações da politica de “mesmo host de origem”, onde o
navegador não permitia que o Javascript fizesse nenhuma chamada para
qualquer outro lugar além do servidor a partir do qual a página
atual foi servida, permitindo que a primeira fraqueza fosse
suavizada. O design abriu a possibilidade de escrever a ligação
protocolo/adaptador de rede do Selenium em várias outras linguagens:
eles só precisavam ser capazes de enviar uma requisição HTML para
uma URL particular. &nbsp;O <U>wire format</U> foi <U>intimamente</U>
modelado de acordo com a sintaxe baseada em tabela do Selenium Core e
isto, juntamente com a sintaxe baseada em tabelas, tornou-se
conhecida como “Selenese”. Porque os <U>vínculos da linguagem</U>
estavam controlando o navegador à distância, a ferramenta foi
chamada de “Selenium Remote Control”, ou “Selenium
RC”.<BR><BR>Enquanto o Selenium estava sendo desenvolvido, outro
framework de automação de navegadores estava sendo preparado no
ThoughtWorks: WebDriver. O código inicial <U>deste</U> foi liberado
<U>precocemente</U> em 2007. WebDriver <U>derivou-se</U> do trabalho
em projetos que queriam <U>isolar a</U> <U>cobertura de testes da
base da ferramenta de testes</U>. Tipicamente, o caminho pelo qual
este isolamento é feito, é através do padrão <U>Adapter.</U>
WebDriver &nbsp;cresceu a partir do conhecimento desenvolvido pela
aplicação desta abordagem coerente ao longo de inúmeros projetos,
e inicialmente era uma capa em torno do HtmlUnit. O suporte do
Internet Explorer e do Firefox sucedeu-se rapidamente após o
lançamento.<BR><BR>Quando o WebDriver foi liberado, existiam
diferenças significantes entre este e o Selenium RC, apesar disto,
eles se mantiveram no mesmo nicho de software de uma API para
automação de navegadores. A diferença mais obvia para um usuário,
era que o Selenium RC tinha uma API baseada em dicionário, com todos
os métodos expostos em uma única classe, equanro o WebDriver tinha
uma API mais orientada a objetos. Além disso, WebDriver apenas
suportava Java, enquanto o Selenium RC oferecia suporte para uma
vasta quantidade de linguagens. Existiam também, fortes diferenças
técnicas: Selenium Core (no qual o RC foi baseado) era
essencialmente uma aplicação Javascript, rodando dentro do <U>sandbox</U>
de segurança do navegador. WebDriver tentou se vincular nativamente
ao navegador, contornando o modelo de segurança do navegador as
custas do significante aumento do esforço no desenvolvimento do
framework em si.<BR><BR>Em agosto de 2009, foi anunciado que os dois
projetos poderiam se fundir, e o Selenium WebDriver é o resultado
destes dois projetos unidos. Enquanto escrevo, o suporte de
linguagens do WebDriver foi aprimorado para Java, C#, Python e Ruby.
Isso oferesse suporte para Chrome, Firefox, Internet Explorer, Opera
e para os navegadores do Iphone e do Android. <U>Existem projetos
irmãos</U>, não mantidos no mesmo repositório de códigos-fonte,
mas trabalhando intimamente com o projeto principal, que fornecem as
ligações do Perl, umas implementações para o navegador do
BlackBerry, e para <U>WebKits</U> <U>“sem cabeça”</U> - <U>útil
para as horas em que os testes precisam ser rodados em um servidor de
integração continua sem uma exibição adequada</U>. O mecanismo
original do Selenium RC ainda é mantido e permite que o WebDriver
forneça suporte para os navegadores que seriam incompatíveis.
<BR><BR>16.2. Uma <U>Digresion</U> sobre Jargon<BR><BR>Infelizmente,
o projeto Selenium utiliza muitos <U>jargões</U>. Recapitulando o
que nós já vimos:</SPAN></FONT></FONT></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Selenium
	Core é o coração da implementação original do Selenium, e é um
	conjunto de scripts Javascript que controlam o navegador. Esta,
	algumas vezes é referenciado como “Selenium” e outras como
	“Core”.</SPAN></FONT></FONT></P>
</UL>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Selenium
	RC foi o nome dado para as <U>ligações</U> das linguagens para o
	Selenium Core, e é comumente, e confusamente, referenciada apenas
	como “Selenium” or como “RC”. Agora, isto tem sido
	substituido pot Selenium WebDriver, onde a API do RC é referenciada
	como o “Selenium 1.x API”.</SPAN></FONT></FONT></P>
</UL>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Selenium
	WebDriver se encaixa no mesmo nicho que o RC <U>fez</U>, &nbsp;e tem
	incluido as ligações originais do 1.x. Isso refere-se a ambos os
	vinculos de linguagem e a implementação de códigos de controle
	individual do navegador. Isto é comumente referenciado apenas como
	“WebDriver” ou, algumas vezes, como Selenium 2. . Sem dúvida,
	esta será contraida para “Selenium” ao longo do tempo.</SPAN></FONT></FONT></P>
</UL>
<P STYLE="margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT FACE="Times New Roman"><SPAN STYLE="background: transparent"><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>O
leitor atento já terá percebido que “Selenium” é usado em um
sentido bastante geral. Felizmente, o contexto deixa claro qual
Selenium as pessoas estão se referindo em particular.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Finalmente,
existe mais uma frase que eu vou estar usando, e não há nenhuma
maneira graciosa de introduzi-la: “driver” é o nome dado para
uma implementação especifica da API do WebDriver. Por exemplo,
existe um driver do Firefox e um driver do Internet Explorer.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.3.
Enredos Arquitetônicos</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Antes
de começarmos a olhar as partes individuais para entender como eles
estão ligados, é útil entender o </FONT></SPAN><FONT SIZE=3><U>grande
enredo</U></FONT><SPAN STYLE="text-decoration: none"> </SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>da
arquitetura e desenvolvimento do projeto. Sucintamente, são eles:</FONT></SPAN></SPAN></FONT></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Manter
	os custos baixos.</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Emular
	o usuário.</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Mostrar
	que os drivers funcionam.</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; widows: 2; orphans: 2; text-decoration: none">
	<SPAN STYLE="background: transparent">…<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">mas
	você não precisa entender como tudo funciona.</SPAN></SPAN></FONT></FONT></SPAN></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent"><U>Deminuir
	o </U><I><U>bus factor</U></I><U>.</U></SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Ter
	simpatia por implementação em Javascript.</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Toda
	chamada de método é uma chamada RPC.</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Nós
	estamos em um projeto Open Source.</SPAN></FONT></FONT></P>
</UL>
<P STYLE="margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT FACE="Times New Roman"><SPAN STYLE="background: transparent"><BR><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.3.1.
Manter os custos baixos</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Suportar
X navegadores em Y plataformas é inerentemente um propósito caro,
tanto em termos de desenvolvimento inicial, quanto em manutenção.
Se pudermos encontrar algum jeito para manter a qualidade do produto
alta sem violar muitos dos outros princípios, então esse é o
caminho a ser seguido. Isso é claramente visto em nossa adoção do
Javascript, onde for possível, como você vai ler sobre em
breve.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.3.2.
Emular o usuário</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>WebDriver
é desenhado para simular perfeitamente o modo que um usuário irá
interagir com uma aplicação web. Uma abordagem comum para simular a
entrada do usuário, é fazer uso do Javascript para sintetizar e
disparar uma série de eventos que um aplicativo veria se um usuário
real estivesse realizando a mesma interação. Esta abordagem de
“eventos sintetizados” é repleta de dificuldades em cada
navegador, e algumas vezes diferentes versões do mesmo navegador,
disparam eventos diferentes, com valores ligeiramente diferentes.
Para complicar, a maioria dos navegadores não permitem ao usuário
interagir desta forma com elementos de formulário, como elementos de
entrada de arquivos por razões de segurança.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Onde
é possível, WebDriver utiliza a abordagem alternativa de disparar
eventos no nível só SO. Como estes “eventos nativos” não são
geradados pelo navegador, esta abordagem contorna as restrições de
segurança colocadas em eventos sintetizados e, porque eles são
específicos do OS, uma vez que estão trabalhando para um navegador
em uma plataforma particular, reusar o código em um outro navegador
é relativamente fácil. Tristemente, esta abordagem só é possível
onde o WebDriver é capaz de se conectar estreitamente com o
navegador e onde o time de desenvolvimento determinou qual a melhor
forma de enviar eventos nativos sem que a janela do navegador esteja
em foco (como os testes no Selenium levam muito tempo para rodar, e
isto é útil para que seja possível utilizar a máquina para outras
tarefas enquanto eles rodam). </FONT></SPAN><FONT SIZE=3><U>Na hora
de escrever</U></FONT><SPAN STYLE="text-decoration: none"><FONT SIZE=3>,
isto significa que eventos nativos podem ser usados no Linux e no
Windows, mas não no Mac OS X.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Não
importa como o WebDriver está emulando a entrada do usuário,
estamos nos esforçando para imitar o comportamento do usuário,
tanto quanto possível. Em contraste como RC, que operava em um nível
muito inferior ao que o usuário trabalha.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.3.3.
Mostre que o drivers funcionam</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Pode
ser um idealismo, coisa de “maternidade e torta de maçã”, mas
eu acredito que não existe sentido em escrever códigos se estes não
funcionam. O jeito de provar que os drivers funcionam no projeto
Selenium é ter um amplo conjunto de casos de teste automatizado.
Estes são tipicamente “testes de integração”, exigindo que o
código seja compilado e faça uso de um navegador que interaja com
um servidor web, mas onde é possível, nós escrevemos “testes
unitátios”, os quais, diferente dos testes de integração, podem
rodar sem uma recompilação completa. </FONT></SPAN><FONT SIZE=3><U>Na
hora de esrever</U></FONT><SPAN STYLE="text-decoration: none"><FONT SIZE=3>,
há cerca de 500 testes de integração e cerca de 250 testes
unitários que poderiam ser rodados em cada navegador. Nós
adicionamos mais, à medida que concertamos falhas e escrevemos novos
códigos, e nosso foco está se deslocando para escrever mais testes
de unidade.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Nem
todo teste é executado em qualquer browser. Alguns recursos de
testes especificos que alguns navegadores não suportam, ou que são
tratadas de formas diferentes em diferentes navegadores. Exemplos
disso são os testes para os novos recursos do HTML5 que não são
suportados em todos os navegadores. Apesar disso, cada um dos mais
importantes navegadores tem um subconjunto significante de testes
rodados através deles. Compreensivelmente, encontrar um jeito de
rodar mais de 500 testes por navegador em múltiplas plataformas é
um desafio significativo, e é com isso que o projeto continua
lutando.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.3.4.
Você não precisa entender como tudo funciona</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Poucos
desenvolvedores são proficientes e confortáveis com as linguagens e
tecnologias que usamos. Consequentemente, nossa arquitetura precisa
permitir aos desenvolvedores focar onde seus talentos podem ser
melhor aproveitados, sem a necessidade de trabalharem em partes da
base de códigos onde se sentem inconfortáveis.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.3.5.
</FONT></SPAN><FONT SIZE=3><U>Diminua o </U></FONT><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>bus
factor</I></FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Há
um (não inteiramente sério) conceito no desenvolvimento de
softwares chamado “</FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>bus
factor</I></FONT></SPAN><SPAN STYLE="text-decoration: none">”</SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>.
Refere-se ao numero de desenvolvedores-chave que devem cumprir um fim
terrível – aparentemente sendo atingido por um ônibus – </FONT></SPAN><FONT SIZE=3><U>para
deixar o projeto em um estado onde não poderia mais continuar</U></FONT><SPAN STYLE="text-decoration: none"><FONT SIZE=3>.
Algo tão complexo quanto automação de navegadores poderia ser
particularmente propensa a isso, então, muitas das nossas decisões
arquiteturais são feitas para este número tão alto quanto
possível.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.3.6.
Tenha simpatia por implementações em Javascript</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>WebDriver
</FONT></SPAN><FONT SIZE=3><U>falha</U></FONT><SPAN STYLE="text-decoration: none">
</SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>em usar
Javascript puro para conduzir o navegador se não existir outro jeito
de conduzi-lo. Isso significa que qualquer API que adicionarmos deve
ser “simpática” para uma implementação em Javascript. Como um
exemplo concreto, HTML5 introduz LocalStorage, uma API para
armazenamento de dados estruturados no lado do cliente.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.3.7.
Toda chamada é uma chamada RPC</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>WebDriver
controla navegadores que estão rodando em outros processos. Embora
seja fácil </FONT></SPAN><FONT SIZE=3><U>ignorá-lo</U></FONT><SPAN STYLE="text-decoration: none"><FONT SIZE=3>,
isso significa que toda chamada que é feita é uma chamada RPC,
então a performance do framework está a mercê da latência da
rede. Em uma operação normal, isso pode não ser terrivelmente
notável - a maioria dos OS’s otimiza o roteamento para o </FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>localhost
- </I></FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>mas
como a latência entre o navegador e o código de teste aumenta, o
que poder ter parecido eficiente se torna menos tanto para os
designers quanto para os usuários desta API.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Isto
introduz uma certa tensão no projeto de APIs. Uma API maior, com
funções mais grosseiras, ajudaria a diminuir a latência </FONT></SPAN><FONT SIZE=3><U>derrubando</U></FONT><SPAN STYLE="text-decoration: none">
</SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>várias
chamadas, mas isso deve ser balanceado, mantendo a API expressiva e
fácil de usar. Por exemplo, há varias verificações que precisam
ser feitas para determinar se um elemento é visível para o usuário
final. Não só precisamos levar em consideração várias
propriedades do CSS, que podem precisar ser inferidos olhando seus
elementos pai, mas devemos checar também as dimensões do elemento.
Uma API minimalista exigiria que cada checagem fosse deita
individualmente. WebDriver detona todas elas com um único método
</FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>isDisplayed.</I></FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.3.8.
Pensamento Final: Isso é </FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>Open
Source</I></FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Embora
este não seja um ponto estritamente arquitetural, Selenium pe um
projeto </FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>Open
Source</I></FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>.
O tema que todos os pontos acima juntos é que nós gostariamos de
faze-lô tão fácil quanto possivel para que um novo desenvolvedor
possa contribuir. Mantendo a profundidade do conhecimento necessário
tão superficial quanto possivel, usando tão poucas linguagens
quanto necessário e contando com testes automatizados para verificar
que nada parou de funcionar, esperamos permitir que este seja de
fácil contribuição.</FONT></SPAN><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Originalmente
o projeto foi divido em uma série de módulos, com cada módulo
representando um navegador em particular com módulos adicionais para
códigos em comum e para suporte e utilidade do código. Árvores
fonte foram armazenadas sob estes módulos. Esta abordagem fez muito
sentido para linguagens como Java e C#, mas era doloroso para
trabalhar com Rubystas e Pythonistas. Isto se traduziu quase
diretamente em um número relativo de contribuidores, com pucas
pessoas interessadas em trabalhar nas partes de Python e Ruby. Para
resolver isso, em Outubro e Novenbro de 2010 o código fonte foi
reorganizado com o códigos Python e Ruby armazenados em um
diretório, na camada mais alta, para cada linguagem. Isto combinou
melhor com as expectativas dos desenvolvedores Open Source destas
linguagens, e o efeito nas contribuições da comunidade foi notável
quese que imediatamente.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.4
Lidando com a Complexidade</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Software
é uma construção irregular. Os nódulos são a complexidade, e
como designers de uma API nós temos uma escolha de onde jogar essa
complexidade. Em um xtremo, poderiamos dividir a complexidade da
maneira mais justa possivel, significando que cada consumidor dessa
API precisa ser parte disso. O outro extremo sugere pegar a maior
parte possível da complexidade e isola-la em um único local. Este
local seria um lugar de escuridão e terror para muitos se estes
tiverem que se aventurar lá, mas a questão é que os usuários da
API, que não precisam se aventurar na sua implementação, têm o
custo da complexidade pago à vista por eles.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Os
desenvolvedores do WebDriver tendem mais à encontrar e isolar a
complexidade em poucos lugares, ao invés de espalha-lá. Uma razão
para isso são nossos usuários. Eles são excepcionalmente bons em
encontrar problemas e falhas, como uma olhada em nossa lista de bugs
mostra, mas como a maioria deles não são desenvolvedores, uma API
complexa não iria funcionar muito bem. Nós procuramos fornecer uma
API que guia as pessoas na direção certa. Como um exemplo,
considere os seguintes métodos da API original do Selenium, cada
qual pode ser usada para definir o valor de entrada de um elemento:</FONT></SPAN></SPAN></FONT></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">type</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">typeKeys</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">typeKeysNative</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">keydown</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">keypress</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">keyup</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">keydownNative</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">keypressNative</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">keyupNative</SPAN></FONT></FONT></P>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">attachFile</SPAN></FONT></FONT></P>
</UL>
<P STYLE="margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT FACE="Times New Roman"><SPAN STYLE="background: transparent"><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Aqui
está o equivalente na API do WebDriver:</FONT></SPAN></SPAN></FONT></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm; background: transparent; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
	<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">sendKeys</SPAN></FONT></FONT></P>
</UL>
<P STYLE="margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT FACE="Times New Roman"><SPAN STYLE="background: transparent"><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Como
discutido anteriormente, isto destaca uma das maiores diferenças
filosóficas entre Rc e WebDriver, na qual o WebDriver se esforça
para emular o usuário, enquanto o RC oferece um nível mais baixo
que um usuário acharia difícil ou impossível de alcançar. A
distinção entre </FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>typeKeys</I></FONT></SPAN><SPAN STYLE="text-decoration: none">
</SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>e
</FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>typeKeysNative
</I></FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>é
que o primeiro sempre usa eventos sintéticos, enquanto o último
atenta para o uso do robo AWT para definir a chaves. Lamentavelmente,
o robo AWT envia a tecla pressionada para qualquer janela que esteja
focada, que não precisa ser necessáriamento o navegador. Eventos
nativos do WebDriver, por outro lado, são enviados diretamente para
o identificador da janela, evitando a necessidade de manter o
navegador no foco.</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.4.1.
O Design do WebDriver</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>A
equipe refere-se a API do WebDriver como sendo “baseada em
objetos”. As interfaces são claramente definidas e tentam se
adequar a ter apenas uma regra ou responsabilidade, mas ao invés de
modelar cada simples tag HTML com sua própria classe, nós temos um
única interface </FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>WebElement</I></FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>.
Ao seguir esta abordagem, desenvolvedores que estão usando um
interface com suporte à preenchimento automático podem ser guiados
ao próximo passo. O resultado é que a sessão de codificação pode
ser parecida com esta (em Java):</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>WebDriver
driver = new FirefoxDriver();<BR>driver.&lt;user hits space&gt;</I></FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Neste
ponto, uma lista relativamente pequena de 13 métodos aparece. O
usuário escolhe uma:</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>driver.findElement(&lt;user
hits space&gt;)</I></FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Agora,
a maioria das IDEs irá mostrar uma dica sobre o tipo de argumento
esperado, neste caso um </FONT></SPAN><U>“</U><FONT SIZE=3><U>By”</U></FONT><SPAN STYLE="text-decoration: none"><FONT SIZE=3>.
&nbsp;Há uma série de métodos pré-configurados para objetos do
tipo “By”, declarados como métodos estáticos em “By”. Noss
usuário rapidamente terminará com uma linha de código parecida com
esta:</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>driver.findElement(By.id(&quot;some_id&quot;));</I></FONT></SPAN></SPAN></FONT></P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">INTERFACES
BASEADAS EM FUNÇÕES</SPAN></FONT></FONT></P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT FACE="Times New Roman"><SPAN STYLE="background: transparent"><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Pense
em uma classe simplificada </FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>Shop.
</I></FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Todos
os dias, ela precisa ser reabastecida, e trabalha em conjundo com um
</FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>Stockist
</I></FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>para
suprir o novo stock. Todos os meses, ela precisa pagar os empregados
e os impostos. Por uma questão de argumento, vamos que ele faz isso
usando um </FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>Accountant</I></FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>.
Uma forma de modalá-lo é:</FONT></SPAN></SPAN></FONT></P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
<FONT FACE="Times New Roman"><FONT SIZE=3><I><SPAN STYLE="background: transparent">public
interface Shop {</SPAN></I></FONT></FONT></P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
<FONT FACE="Times New Roman"><FONT SIZE=3><I><SPAN STYLE="background: transparent">void
addStock(StockItem item, int quantity);</SPAN></I></FONT></FONT></P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
<FONT FACE="Times New Roman"><FONT SIZE=3><I><SPAN STYLE="background: transparent">Money
getSalesTotal(Date startDate, Date endDate);</SPAN></I></FONT></FONT></P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
<FONT FACE="Times New Roman"><FONT SIZE=3><I><SPAN STYLE="background: transparent">}</SPAN></I></FONT></FONT></P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Nós
temos duas escolhas sobre onde colocar os limites na hora de definir
a interfaxe entre o Shop, o Accountant e o Stockist. Nós poderiamos
desenhar uma linha teórica, como é mostrado na figura 16.1.</SPAN></FONT></FONT></P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT FACE="Times New Roman"><SPAN STYLE="background: transparent"><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Isso
significa que tanto </FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>Account</I></FONT></SPAN><SPAN STYLE="text-decoration: none">
</SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>quanto
</FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>Stockist</I></FONT></SPAN><SPAN STYLE="text-decoration: none">
</SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>aceitariam
</FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>Shop
</I></FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>como
um argumento de seus respectivos métodos. A desvantagem aqui, porém,
é que é improvável que o Accountant realmente quer amontoar
</FONT></SPAN><FONT SIZE=3><U>SHELVES</U></FONT><SPAN STYLE="text-decoration: none"><FONT SIZE=3>,
e provavelmente não é uma boa idéia para o Stockist, realizar a
ampla </FONT></SPAN><FONT SIZE=3><U>checagem</U></FONT><SPAN STYLE="text-decoration: none">
</SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>nos preços
que o Shop está adicionando. Então, a lugar melhor para desenhar a
linha é mostrana na figura 16.2.</FONT></SPAN></SPAN></FONT></P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Nós
precesaremos de duas interfaces que o Shop precisa implementar, mas
estas interfaces definem claramente o papel que o Shop cumpre, tanto
para o Accountant, quanto para o Stockist. Elas são interfaces
baseadas em funções:</SPAN></FONT></FONT></P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
<FONT FACE="Times New Roman"><FONT SIZE=3><I><SPAN STYLE="background: transparent">public
interface HasBalance {<BR>&nbsp;&nbsp;&nbsp;Money getSalesTotal(Date
startDate, Date endDate);<BR>}<BR><BR>public interface Stockable
{<BR>&nbsp;&nbsp;&nbsp;void addStock(StockItem item, int
quantity);<BR>}<BR><BR>public interface Shop extends HasBalance,
Stockable {<BR>}</SPAN></I></FONT></FONT></P>
<P STYLE="margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT FACE="Times New Roman"><SPAN STYLE="background: transparent"><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Acho
</FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>UnsupportedOperationExceptions</I></FONT></SPAN><SPAN STYLE="text-decoration: none">
</SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>e suas
classes profundamente desagradáveis, mas é preciso haver algo que
permita que a funcionalidade seja exposta para o subconjunto de
usuários que podem vir a precisar dela, sem sobrecarregar o restante
da API para o restante dos usuários. Em fim, WebDriver faz um
extenso uso de insterfaces baseadas em funções. Por exemplo. há
uma interface </FONT></SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3><I>JavascriptExecutor</I></FONT></SPAN><SPAN STYLE="text-decoration: none">
</SPAN><SPAN STYLE="text-decoration: none"><FONT SIZE=3>que provê a
habilidade de executar blocos arbitrários de Javascript no contexto
da página atual. Um lançamento perfeito de uma instância do
WebDriver para aquela interface, indica que você pode esperar que os
métodos desta funcionem.</FONT></SPAN></SPAN></FONT></P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Figura
16.1: Accountant e Stockinst dependem de Shop</SPAN></FONT></FONT></P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-left: 1.24cm; margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Figura
16.2: Shop implementa HasBalance e Stockable</SPAN></FONT></FONT></P>
<P STYLE="margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT FACE="Times New Roman"><SPAN STYLE="background: transparent"><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>16.4.2.
Lidar com a explosão combinatória</FONT></SPAN><BR><BR><SPAN STYLE="text-decoration: none"><FONT SIZE=3>Uma
das primeiras coisas que resulta um momento de reflexão sobre a
vasta gama de navegadores e linguagens que o WebDriver suporta, é
que a menos que se tenha cuidado, os custos de manutenção podem
tomar um caminho crescente. Com X navegadores e Y linguagens, seria
fácil cair na armadilha de manter XxY implementações.<BR><BR>Reduzir
o número de linguagens suportadas pelo WebDriver seria uma maneira
de reduzir seus custos, mas não queremos pegar este caminho por dois
motivos. Primeiramente, existe uma carga cognitiva a ser paga quando
se muda de uma linguagem para outra, por isso é vantajoso para os
usuários do framework poderem escrever seus testes na mesma
linguagem em que utilizam na maior parte do projeto no qual
trabalham. Em segundo lugar, misturar muitas linguagens em um simples
projeto é algo que não vai deixar a equipe confortável, e padrões
de codificação corporativa e requerimentos frequentemente parecem
demandar um tecnologia monocultura (embora, agradável, ei penso que
esta segunda opção está se tornando menos verdadeira ao longo do
tempo), contudo reduzir o número de linguagens suportadas não é
uma opção disponível.</FONT></SPAN></SPAN></FONT></P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2; text-decoration: none">
<FONT FACE="Times New Roman"><FONT SIZE=3><SPAN STYLE="background: transparent">Reduzir
o numero de navegadores suportados também não é uma opção
disponível – haviam fortes argumentos quando eliminamos o suporte
ao Firefox 2 no WebDriver, apesar do fato de que quando fizemos essa
escolha, representava menos de 1% do mercado de navegadores.</SPAN></FONT></FONT></P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2">A única escolha
que nos resta é tentar e fazer todos os navegadores parecerem
idênticos para as ligações da linguagem: eles devem oferecer um
interface uniforme que pode ser facilmente tratada em uma ampla
variedade de linguagens. Além do mais, queremos as ligações das
linguagens em si sejam tão fáceis de escrever quanto possível. Nós
empurramos, tanta lógica quanto pudemos, para o drive subjacente, a
fim de apoiar esta: cada pedaço de funcionalidade que nós falhamos
em colocar dentro do driver é algo que precisa ser implementado em
todas as linguagens que damos suporte, e isso pode representar uma
quantidade significativa de trabalho.</P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2">Como um exemplo,
o driver do IE foi, com sucesso, alocado à responsabilidade de
localizar e iniciar o IE, dentro do driver lógico principal. Contudo
isso resultou em um surpreendente numero de linhas de código no
driver, as ligações da linguagem para criar uma nova instância
resume-se em uma simples chamada de método dentro do driver. Para
comparação, o driver do Firefox não conseguiu fazer esta
alteração. No mundo Java por si só, isso significa que nós temos
três classes principais que tratam de configurar e iniciar o
Firefox, pesando em torno de 1300 linhas de código. Estas classes
são duplicadas em toda as linguagens que querem suportar o driver do
Firefox sem precisar levantar um servidor Java. Isso é bastante
código adicional para manter.</P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2">16.4.3. Falhas
no design do WebDriver</P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2">O lado ruim da
decisão de expor os recursos desta forma, é que até que alguém
saiba que existe uma interface especifica, eles podem não perceber
que o WebDriver suporta este tipo de funcionalidade; há uma perda de
usabilidade na API. Certamente quando o WebDriver era novo, nós
parecíamos perder muito tempo apenas dirigindo as pessoas para
interfaces especificas. Nós pomos agora muuito mais esforço em
nossa documentação e como a API se tornou mais usada se torna fácil
de usar e fácil para os usuários encontrarem a informação que
precisam. 
</P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2">Há um lugar
onde eu penso que nossa API é particularmente pobre. Nós temos uma
interface chamada <FONT FACE="Courier 10 Pitch"><FONT SIZE=2>RenderedWebElement</FONT></FONT>
que tem uma estranha miscelânea de métodos para fazer a consulta do
estado do elemento renderizado (<FONT FACE="Courier 10 Pitch">isDisplayed</FONT>,
<FONT FACE="Courier 10 Pitch">getSize</FONT> and <FONT FACE="Courier 10 Pitch">getLocation</FONT>),
realizando operações sobre ele ( <FONT FACE="Courier 10 Pitch">hover</FONT>
e methodos para arrastar e soltar), e um método útil para obter o
valor de uma propriedade CSS em particular. Ele foi criado porque o
driver HtmlUnit não expunha as informações desejadas, mas os
drivers do Firefox e do IE expuseram. Originalmente havia apenas o
primeiro conjunto de metodos mas nós adicionamos os outros métodos
antes de eu ter pensado muito sobre como eu queria que a API
evoluísse. A interface é bem conhecida agora, e  a escolha mais
difícil é se mantemos esta extremidade feia da API dado que esta é
amplamente usada, ou se tentamos deletá-la. Minha preferencia é não
deixar uma “janela quebrada” para trás, então é importante
concertá-la antes de liberarmos o Selenium 2.0. Como um resultado,
enquanto você lê este capitulo, RenderedWebElement pode muito bem
ter ido embora.</P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P STYLE="margin-bottom: 0cm; widows: 2; orphans: 2">Do ponto de
vista do implementador, uma forte ligação com o browser também é
uma falha de design, apesar de não termos outra escolha. Isto
consome um esforço significante para suportarmos um novo browser,  e
frequentemente vários esforços necessitam ser feitos para que tudo
ocorra bem. Como um exemplo concreto, o driver do Chrome foi
reescrito quatro vezes, e o driver do IE, três. A vantagem de se
estabelecer uma forte ligação com o browser é que se tem mais
controle sobre o mesmo.</P>
</BODY>
</HTML>
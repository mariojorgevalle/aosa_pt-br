Tradução CAP 16 

Capítulo 16 - Selenium WebDriver 

Simon Stewart 

Selenium é uma ferramenta para automação de navegadores, comumente usada para escrever testes de aplicações web de ponta-a-ponta. Uma ferramenta de automação de navegadores faz o exatamente o que você esperaria: automatiza o controle de um navegador, sendo assim, tarefas repetitivas podem ser automatizadas. Isto parece um simples problema a ser resolvido, mas como veremos, muitas coisas têm que acontecer debaixo dos panos para que tudo funcione. 

Antes de descrever a arquitetura do Selenium é necessário entender como as várias partes do projeto se encaixam. Por cima, Selenium é uma coleção de três ferramentas. A primeira destas, Selenium IDE, é uma extensão para Firefox que permite aos usuários gravar e refazer testes. O paradigma gravar/refazer pode ser limitado e não adaptável para muitos usuários, então a segunda ferramenta da coleção, Selenium WebDriver, provê APIs em várias linguagens para permitir um maior controle e aplicação de praticas de desenvolvimento de software padrão. A última ferramenta, Selenium Grid, torna possível o uso das APIs do Selenium para controlar instâncias de navegadores distribuídas sobre um rede de máquinas, permitindo executar mais testes paralelamente. No interior do projeto, eles são referenciados como "IDE", "WebDriver" e "Grid". Este capítulo explora a arquitetura do Selenium WebDriver. 

Este capítulo foi escrito durante os betas do Selenium 2.0 no final de 2010. Se você está lendo o livro após o fim de 2010, então as coisas já terão avançado, e você será capaz de ver como as escolhas arquiteturais descritas aqui se desdobraram. Se você está lendo antes do fim de 2010: Parabéns! Você tem uma máquina do tempo. Pode me dar os números vencedores da loteria? 

16.1. História 

Jason Huggins começou o projeto Selenium em 2004 enquanto trabalhava no ThoughtWorks do sistema feito por eles, Time and Expenses (T&E), que fez amplo uso de Javascript. Embora o Internet Explorer fosse o navegador dominante na época, ThoughtWorks usou vários navegadores alternativos (em particular, as variações do Mozzila) e enviava um relatório de erro quando o aplicativo T&E não funcionava no navegador escolhido. Ferramentas de testes naquela época, ou eram focadas em um único navegador (normalmente IE) ou eram simulações de um navegador (como HttpUnit). O custo de uma licença para uma ferramenta comercial teria esgotado o orçamento limitado de um pequeno projeto interno, então eles nem mesmo consideraram como uma alternativa viável. 

Onde a automação de testes se torna difícil, é comum recorrer à testes manuais. Está abordagem não funciona quando a equipe é muito pequena ou quando a liberação de novas versões é extremamente frequente. É também uma falta de humanidade, pedir a uma pessoa que revise um código que poderia ser automatizado. Comumente, pessoas são mais lentas e mais susceptíveis à erros em tarefas repetitivas do que máquinas. Teste manual não era um opção.

Felizmente, todos os navegadores que foram testados suportavam Javascript. Escrever um ferramenta de teste nesta linguagem, fez sentido para Jason e a equipe com a qual ele trabalhava, pois esta poderia ser usada para verificar o comportamento da aplicação. Inspirado pelo trabalho feito no FIT¹, uma sintaxe baseada em tabelas (table-based) foi colocada sobre o Javascript puro e isso permitiu que os testes fossem escritos por pessoas com experiência limitada em programação usando uma abordagem baseada em palavras chave (keyword-based) em arquivos HTML. Esta ferramenta, originalmente chamada de “Selenium” mas depois referenciada como “Selenium Core”, foi liberada em 2004 sob a licença Apache 2.

A formatação em tabelas do Selenium é estruturada similarmente ao ActionFixture presente no FIT. Cada linha da tabela é dividida em três colunas. A primeira coluna contém o nome do comando a ser executado, a segunda coluna tipicamente contém um elemento identificador e a terceira coluna contém um valor opcional. Por exemplo, isto é como definir a string “Selenium WebDriver” dentro de um elemento identificado pelo nome “q”:

type name=q Selenium WebDriver


Pelo fato do Selenium ter sido escrito em Javascript puro, seu design inicial requeria que os desenvolvedores hospedassem o Core e seus testes no mesmo servidor em que estava a aplicação a ser testada (AUT) para evitar falhas grosseiras das politicas de segurança do navegador e do Javascript sandbox. Isso nem sempre era prático ou possível. E pior, ainda que a IDE dos desenvolvedores lhes desse habilidade para rapidamente manipular o código e navegar pela extensa coleção de códigos-fonte (codebade), não existe tal ferramenta para HTML. Rapidamente se tornou claro que manter uma coleção de testes pela metade era um propósito incômodo e doloroso.

Para resolver este e outros problemas, um proxy HTTP foi escrito para que toda solicitação HTTP pudesse ser interceptada pelo Selenium. Usando este proxy, tornou-se possível desviar de muitas das limitações da politica de “mesmo host de origem”, onde o navegador não permitia que o Javascript fizesse nenhuma chamada para qualquer outro lugar além do servidor a partir do qual a página atual foi servida, permitindo que a primeira fraqueza fosse suavizada. O design abriu a possibilidade de escrever a ligação protocolo/adaptador de rede do Selenium em várias outras linguagens: eles só precisavam ser capazes de enviar uma requisição HTML para uma URL particular. O wire format foi intimamente modelado de acordo com a sintaxe baseada em tabela do Selenium Core e isto, juntamente com a sintaxe baseada em tabelas, tornou-se conhecida como “Selenese”. Porque os vínculos da linguagem estavam controlando o navegador à distância, a ferramenta foi chamada de “Selenium Remote Control”, ou “Selenium RC”.

Enquanto o Selenium estava sendo desenvolvido, outro framework de automação de navegadores estava sendo preparado no ThoughtWorks: WebDriver. O código inicial deste foi liberado precocemente em 2007. WebDriver derivou-se do trabalho em projetos que queriam isolar a cobertura de testes da base da ferramenta de testes. Tipicamente, o caminho pelo qual este isolamento é feito, é através do padrão Adapter. WebDriver cresceu a partir do conhecimento desenvolvido pela aplicação desta abordagem coerente ao longo de inúmeros projetos, e inicialmente era uma capa em torno do HtmlUnit. O suporte do Internet Explorer e do Firefox sucedeu-se rapidamente após o lançamento.

Quando o WebDriver foi liberado, existiam diferenças significantes entre este e o Selenium RC, apesar disto, eles se mantiveram no mesmo nicho de software de uma API para automação de navegadores. A diferença mais obvia para um usuário, era que o Selenium RC tinha uma API baseada em dicionário, com todos os métodos expostos em uma única classe, equanro o WebDriver tinha uma API mais orientada a objetos. Além disso, WebDriver apenas suportava Java, enquanto o Selenium RC oferecia suporte para uma vasta quantidade de linguagens. Existiam também, fortes diferenças técnicas: Selenium Core (no qual o RC foi baseado) era essencialmente uma aplicação Javascript, rodando dentro do sandbox de segurança do navegador. WebDriver tentou se vincular nativamente ao navegador, contornando o modelo de segurança do navegador as custas do significante aumento do esforço no desenvolvimento do framework em si.

Em agosto de 2009, foi anunciado que os dois projetos poderiam se fundir, e o Selenium WebDriver é o resultado destes dois projetos unidos. Enquanto escrevo, o suporte de linguagens do WebDriver foi aprimorado para Java, C#, Python e Ruby. Isso oferesse suporte para Chrome, Firefox, Internet Explorer, Opera e para os navegadores do Iphone e do Android. Existem projetos irmãos, não mantidos no mesmo repositório de códigos-fonte, mas trabalhando intimamente com o projeto principal, que fornecem as ligações do Perl, umas implementações para o navegador do BlackBerry, e para WebKits “sem cabeça” - útil para as horas em que os testes precisam ser rodados em um servidor de integração continua sem uma exibição adequada. O mecanismo original do Selenium RC ainda é mantido e permite que o WebDriver forneça suporte para os navegadores que seriam incompatíveis. 

16.2. Uma Digresion sobre Jargon

Infelizmente, o projeto Selenium utiliza muitos jargões. Recapitulando o que nós já vimos:

Selenium Core é o coração da implementação original do Selenium, e é um conjunto de scripts Javascript que controlam o navegador. Esta, algumas vezes é referenciado como “Selenium” e outras como “Core”.

Selenium RC foi o nome dado para as ligações das linguagens para o Selenium Core, e é comumente, e confusamente, referenciada apenas como “Selenium” or como “RC”. Agora, isto tem sido substituido pot Selenium WebDriver, onde a API do RC é referenciada como o “Selenium 1.x API”.

Selenium WebDriver se encaixa no mesmo nicho que o RC fez, e tem incluido as ligações originais do 1.x. Isso refere-se a ambos os vinculos de linguagem e a implementação de códigos de controle individual do navegador. Isto é comumente referenciado apenas como “WebDriver” ou, algumas vezes, como Selenium 2. . Sem dúvida, esta será contraida para “Selenium” ao longo do tempo.

O leitor atento já terá percebido que “Selenium” é usado em um sentido bastante geral. Felizmente, o contexto deixa claro qual Selenium as pessoas estão se referindo em particular.

Finalmente, existe mais uma frase que eu vou estar usando, e não há nenhuma maneira graciosa de introduzi-la: “driver” é o nome dado para uma implementação especifica da API do WebDriver. Por exemplo, existe um driver do Firefox e um driver do Internet Explorer.

16.3. Enredos Arquitetônicos

Antes de começarmos a olhar as partes individuais para entender como eles estão ligados, é útil entender o grande enredo da arquitetura e desenvolvimento do projeto. Sucintamente, são eles:
Manter os custos baixos.
Emular o usuário.
Mostrar que os drivers funcionam.
…mas você não precisa entender como tudo funciona.
Deminuir o bus factor.
Ter simpatia por implementação em Javascript.
Toda chamada de método é uma chamada RPC.
Nós estamos em um projeto Open Source.


16.3.1. Manter os custos baixos

Suportar X navegadores em Y plataformas é inerentemente um propósito caro, tanto em termos de desenvolvimento inicial, quanto em manutenção. Se pudermos encontrar algum jeito para manter a qualidade do produto alta sem violar muitos dos outros princípios, então esse é o caminho a ser seguido. Isso é claramente visto em nossa adoção do Javascript, onde for possível, como você vai ler sobre em breve.

16.3.2. Emular o usuário

WebDriver é desenhado para simular perfeitamente o modo que um usuário irá interagir com uma aplicação web. Uma abordagem comum para simular a entrada do usuário, é fazer uso do Javascript para sintetizar e disparar uma série de eventos que um aplicativo veria se um usuário real estivesse realizando a mesma interação. Esta abordagem de “eventos sintetizados” é repleta de dificuldades em cada navegador, e algumas vezes diferentes versões do mesmo navegador, disparam eventos diferentes, com valores ligeiramente diferentes. Para complicar, a maioria dos navegadores não permitem ao usuário interagir desta forma com elementos de formulário, como elementos de entrada de arquivos por razões de segurança.

Onde é possível, WebDriver utiliza a abordagem alternativa de disparar eventos no nível só SO. Como estes “eventos nativos” não são geradados pelo navegador, esta abordagem contorna as restrições de segurança colocadas em eventos sintetizados e, porque eles são específicos do OS, uma vez que estão trabalhando para um navegador em uma plataforma particular, reusar o código em um outro navegador é relativamente fácil. Tristemente, esta abordagem só é possível onde o WebDriver é capaz de se conectar estreitamente com o navegador e onde o time de desenvolvimento determinou qual a melhor forma de enviar eventos nativos sem que a janela do navegador esteja em foco (como os testes no Selenium levam muito tempo para rodar, e isto é útil para que seja possível utilizar a máquina para outras tarefas enquanto eles rodam). Na hora de escrever, isto significa que eventos nativos podem ser usados no Linux e no Windows, mas não no Mac OS X.

Não importa como o WebDriver está emulando a entrada do usuário, estamos nos esforçando para imitar o comportamento do usuário, tanto quanto possível. Em contraste como RC, que operava em um nível muito inferior ao que o usuário trabalha.

16.3.3. Mostre que o drivers funcionam

Pode ser um idealismo, coisa de “maternidade e torta de maçã”, mas eu acredito que não existe sentido em escrever códigos se estes não funcionam. O jeito de provar que os drivers funcionam no projeto Selenium é ter um amplo conjunto de casos de teste automatizado. Estes são tipicamente “testes de integração”, exigindo que o código seja compilado e faça uso de um navegador que interaja com um servidor web, mas onde é possível, nós escrevemos “testes unitátios”, os quais, diferente dos testes de integração, podem rodar sem uma recompilação completa. Na hora de esrever, há cerca de 500 testes de integração e cerca de 250 testes unitários que poderiam ser rodados em cada navegador. Nós adicionamos mais, à medida que concertamos falhas e escrevemos novos códigos, e nosso foco está se deslocando para escrever mais testes de unidade.

Nem todo teste é executado em qualquer browser. Alguns recursos de testes especificos que alguns navegadores não suportam, ou que são tratadas de formas diferentes em diferentes navegadores. Exemplos disso são os testes para os novos recursos do HTML5 que não são suportados em todos os navegadores. Apesar disso, cada um dos mais importantes navegadores tem um subconjunto significante de testes rodados através deles. Compreensivelmente, encontrar um jeito de rodar mais de 500 testes por navegador em múltiplas plataformas é um desafio significativo, e é com isso que o projeto continua lutando.

16.3.4. Você não precisa entender como tudo funciona

Poucos desenvolvedores são proficientes e confortáveis com as linguagens e tecnologias que usamos. Consequentemente, nossa arquitetura precisa permitir aos desenvolvedores focar onde seus talentos podem ser melhor aproveitados, sem a necessidade de trabalharem em partes da base de códigos onde se sentem inconfortaveis.

16.3.5. Diminua o bus factor

Há um (não inteiramente sério) conceito no desenvolvimento de softwares chamado “bus factor”. Refere-se ao numero de desenvolvedores-chave que devem cumprir um fim terrível – aparentemente sendo atingido por um ônibus – para deixar o projeto em um estado onde não poderia mais continuar. Algo tão complexo quanto automação de navegadores poderia ser particularmente propensa a isso, então, muitas das nossas decisões arquiteturais são feitas para este número tão alto quanto possível.

16.3.6. Tenha simpatia por implementações em Javascript

WebDriver falha em usar Javascript puro para conduzir o navegador se não existir outro jeito de conduzi-lo. Isso significa que qualquer API que adicionarmos deve ser “simpática” para uma implementação em Javascript. Como um exemplo concreto, HTML5 introduz LocalStorage, uma API para armazenamento de dados estruturados no lado do cliente.

16.3.7. Toda chamada é uma chamada RPC

WebDriver controla navegadores que estão rodando em outros processos. Embora seja fácil ignorá-lo, isso significa que toda chamada que é feita é uma chamada RPC, então a performance do framework está a mercê da latência da rede. Em uma operação normal, isso pode não ser terrivelmente notável - a maioria dos OS’s otimiza o roteamento para o localhost - mas como a latência entre o navegador e o código de teste aumenta, o que poder ter parecido eficiente se torna menos tanto para os designers quanto para os usuários desta API.

Isto introduz uma certa tensão no projeto de APIs. Uma API maior, com funções mais grosseiras, ajudaria a diminuir a latência derrubando várias chamadas, mas isso deve ser balanceado, mantendo a API expressiva e fácil de usar. Por exemplo, há varias verificações que precisam ser feitas para determinar se um elemento é visível para o usuário final. Não só precisamos levar em consideração várias propriedades do CSS, que podem precisar ser inferidos olhando seus elementos pai, mas devemos checar também as dimensões do elemento. Uma API minimalista exigiria que cada checagem fosse deita individualmente. WebDriver detona todas elas com um único método isDisplayed.

16.3.8. Pensamento Final: Isso é Open Source

Embora este não seja um ponto estritamente arquitetural, Selenium pe um projeto Open Source. O tema que todos os pontos acima juntos é que nós gostariamos de faze-lô tão fácil quanto possivel para que um novo desenvolvedor possa contribuir. Mantendo a profundidade do conhecimento necessário tão superficial quanto possivel, usando tão poucas linguagens quanto necessário e contando com testes automatizados para verificar que nada parou de funcionar, esperamos permitir que este seja de fácil contribuição.
Originalmente o projeto foi divido em uma série de módulos, com cada módulo representando um navegador em particular com módulos adicionais para códigos em comum e para suporte e utilidade do código. Árvores fonte foram armazenadas sob estes módulos. Esta abordagem fez muito sentido para linguagens como Java e C#, mas era doloroso para trabalhar com Rubystas e Pythonistas. Isto se traduziu quase diretamente em um número relativo de contribuidores, com pucas pessoas interessadas em trabalhar nas partes de Python e Ruby. Para resolver isso, em Outubro e Novenbro de 2010 o código fonte foi reorganizado com o códigos Python e Ruby armazenados em um diretório, na camada mais alta, para cada linguagem. Isto combinou melhor com as expectativas dos desenvolvedores Open Source destas linguagens, e o efeito nas contribuições da comunidade foi notável quese que imediatamente.

16.4 Lidando com a Complexidade

Software é uma construção irregular. Os nódulos são a complexidade, e como designers de uma API nós temos uma escolha de onde jogar essa complexidade. Em um xtremo, poderiamos dividir a complexidade da maneira mais justa possivel, significando que cada consumidor dessa API precisa ser parte disso. O outro extremo sugere pegar a maior parte possível da complexidade e isola-la em um único local. Este local seria um lugar de escuridão e terror para muitos se estes tiverem que se aventurar lá, mas a questão é que os usuários da API, que não precisam se aventurar na sua implementação, têm o custo da complexidade pago à vista por eles.

Os desenvolvedores do WebDriver tendem mais à encontrar e isolar a complexidade em poucos lugares, ao invés de espalha-lá. Uma razão para isso são nossos usuários. Eles são excepcionalmente bons em encontrar problemas e falhas, como uma olhada em nossa lista de bugs mostra, mas como a maioria deles não são desenvolvedores, uma API complexa não iria funcionar muito bem. Nós procuramos fornecer uma API que guia as pessoas na direção certa. Como um exemplo, considere os seguintes métodos da API original do Selenium, cada qual pode ser usada para definir o valor de entrada de um elemento:

type
typeKeys
typeKeysNative
keydown
keypress
keyup
keydownNative
keypressNative
keyupNative
attachFile

Aqui está o equivalente na API do WebDriver:

sendKeys

Como discutido anteriormente, isto destaca uma das maiores diferenças filosóficas entre Rc e WebDriver, na qual o WebDriver se esforça para emular o usuário, enquanto o RC oferece um nível mais baixo que um usuário acharia difícil ou impossível de alcançar. A distinção entre typeKeys e typeKeysNative é que o primeiro sempre usa eventos sintéticos, enquanto o último atenta para o uso do robo AWT para definir a chaves. Lamentavelmente, o robo AWT envia a tecla pressionada para qualquer janela que esteja focada, que não precisa ser necessáriamento o navegador. Eventos nativos do WebDriver, por outro lado, são enviados diretamente para o identificador da janela, evitando a necessidade de manter o navegador no foco.

16.4.1. O Design do WebDriver

A equipe refere-se a API do WebDriver como sendo “baseada em objetos”. As interfaces são claramente definidas e tentam se adequar a ter apenas uma regra ou responsabilidade, mas ao invés de modelar cada simples tag HTML com sua própria classe, nós temos um única interface WebElement. Ao seguir esta abordagem, desenvolvedores que estão usando um interface com suporte à preenchimento automático podem ser guiados ao próximo passo. O resultado é que a sessão de codificação pode ser parecida com esta (em Java):

WebDriver driver = new FirefoxDriver();
driver.<user hits space>

Neste ponto, uma lista relativamente pequena de 13 métodos aparece. O usuário escolhe uma:

driver.findElement(<user hits space>)

Agora, a maioria das IDEs irá mostrar uma dica sobre o tipo de argumento esperado, neste caso um “By”. Há uma série de métodos pré-configurados para objetos do tipo “By”, declarados como métodos estáticos em “By”. Noss usuário rapidamente terminará com uma linha de código parecida com esta:

driver.findElement(By.id("some_id"));



INTERFACES BASEADAS EM FUNÇÕES

Pense em uma classe simplificada Shop. Todos os dias, ela precisa ser reabastecida, e trabalha em conjundo com um Stockist para suprir o novo stock. Todos os meses, ela precisa pagar os empregados e os impostos. Por uma questão de argumento, vamos que ele faz isso usando um Accountant. Uma forma de modalá-lo é:

public interface Shop {
void addStock(StockItem item, int quantity);
Money getSalesTotal(Date startDate, Date endDate);
}

Nós temos duas escolhas sobre onde colocar os limites na hora de definir a interfaxe entre o Shop, o Accountant e o Stockist. Nós poderiamos desenhar uma linha teórica, como é mostrado na figura 16.1.

Isso significa que tanto Account quanto Stockist aceitariam Shop como um argumento de seus respectivos métodos. A desvantagem aqui, porém, é que é improvável que o Accountant realmente quer amontoar SHELVES, e provavelmente não é uma boa idéia para o Stockist, realizar a ampla checagem nos preços que o Shop está adicionando. Então, a lugar melhor para desenhar a linha é mostrana na figura 16.2.

Nós precesaremos de duas interfaces que o Shop precisa implementar, mas estas interfaces definem claramente o papel que o Shop cumpre, tanto para o Accountant, quanto para o Stockist. Elas são interfaces baseadas em funções:

public interface HasBalance {
Money getSalesTotal(Date startDate, Date endDate);
}

public interface Stockable {
void addStock(StockItem item, int quantity);
}

public interface Shop extends HasBalance, Stockable {
}

Acho UnsupportedOperationExceptions e suas classes profundamente desagradáveis, mas é preciso haver algo que permita que a funcionalidade seja exposta para o subconjunto de usuários que podem vir a precisar dela, sem sobrecarregar o restante da API para o restante dos usuários. Em fim, WebDriver faz um extenso uso de insterfaces baseadas em funções. Por exemplo. há uma interface JavascriptExecutor que provê a habilidade de executar blocos arbitrários de Javascript no contexto da página atual. Um lançamento perfeito de uma instância do WebDriver para aquela interface, indica que você pode esperar que os métodos desta funcionem.

Figura 16.1: Accountant e Stockinst dependem de Shop

Figura 16.2: Shop implementa HasBalance e Stockable


16.4.2. Lidar com a explosão combinatória

Uma das primeiras coisas que resulta um momento de reflexão sobre a vasta gama de navegadores e linguagens que o WebDriver suporta, é que a menos que se tenha cuidado, os custos de manutenção podem tomar um caminho crescente. Com X navegadores e Y linguagens, seria fácil cair na armadilha de manter XxY implementações.


<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="BrOffice 3.3  (Unix)">
	<META NAME="AUTHOR" CONTENT="Mario Amaral">
	<META NAME="CREATED" CONTENT="20110531;21293400">
	<META NAME="CHANGEDBY" CONTENT="Mario Amaral">
	<META NAME="CHANGED" CONTENT="20110721;13594400">
	<META NAME="CHANGEDBY" CONTENT="Mario Amaral">
	<META NAME="CHANGEDBY" CONTENT="Mario Amaral">
	<META NAME="CHANGEDBY" CONTENT="Mario Amaral">
	<META NAME="CHANGEDBY" CONTENT="Mario Amaral">
	<META NAME="CHANGEDBY" CONTENT="Mario Amaral">
	<STYLE TYPE="text/css">
	<!--
		@page { margin: 2cm }
		P { margin-bottom: 0.21cm }
		H2 { margin-bottom: 0.21cm }
		H2.cjk { font-family: "WenQuanYi Micro Hei" }
		H2.ctl { font-family: "Lohit Hindi" }
		A:link { so-language: zxx }
		CODE.cjk { font-family: "WenQuanYi Micro Hei", monospace }
	-->
	</STYLE>
</HEAD>
<BODY LANG="pt-BR" DIR="LTR">
<P ALIGN=JUSTIFY><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><FONT SIZE=4><I>Capítulo
18. SnowFlock</I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY><BR><BR>
</P>
<P ALIGN=JUSTIFY><FONT COLOR="#000000"><FONT FACE="arial, sans-serif">A
<SPAN STYLE="background: #ffffff">computação na nuvem (Cloud
Computing)</SPAN> oferece uma plataforma atrativa de computação
acessível. Ao invés de comprar e configurar um servidor físico,
<SPAN STYLE="background: #00ffff">com todo o tempo envolvido</SPAN><SPAN STYLE="background: #ffffff">,
esforço e custo inicial, os usuários podem alugar “servidores”
na nuvem com alguns 'cliques' do </SPAN><I><SPAN STYLE="background: #ffffff">mouse</SPAN></I><SPAN STYLE="background: #ffffff">
por menos de 10 </SPAN><I><SPAN STYLE="background: #ffffff">cents</SPAN></I><SPAN STYLE="background: #ffffff">
por hora. Os provedores da computação na nuvem mantém seus custos
baixo por prover Máquinas Virtuais(MVs – Virtual Machine) ao invés
de computadores físicos. O fator decisivo é o software de
virtualização , chamado de Monitor de Máquina Virtual (Virtual
Machine Monitor – VMM), que emula uma máquina física. Usuários
estão seguramente isolados em suas respectivas MVs, e estão
alegremente inconscientes que normalmente compartilham a máquina
física (“host”) com muitos outros.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY><BR><BR>
</P>
<P ALIGN=JUSTIFY><FONT COLOR="#000000"><FONT FACE="arial, sans-serif">18.1.
<FONT SIZE=4><I>Introduzindo SnowFlock</I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY><BR><BR>
</P>
<P ALIGN=JUSTIFY><FONT COLOR="#000000"><FONT FACE="arial, sans-serif">A
computação na nuvem é uma <SPAN STYLE="background: #ffff00">benção</SPAN><SPAN STYLE="background: #ffffff">
para as organizações agéis. Com servidores físicos, usuários são
obrigados a esperar impacientemente enquanto outros (lentamente)
aprovam a compra do servidor, o lugar para fazer o pedido, alocar o
servidor, instalar e configurar o Sistema Operacional (SO) e todos os
aplicativos. Em vez de esperar semanas pelos outros para a entrega, o
usuário da nuvem mantem o controle do processo e pode criar um novo
servidor autônomo em minutos.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY><FONT COLOR="#000000"><FONT FACE="arial, sans-serif">Infelizmente,
poucos servidores de computação na nuvem são autônomos <SPAN STYLE="background: #ffff00">(few
cloud servers stand alone)</SPAN>. Guiados pela instanciação rápida
e pelo modelo <I>pay-per-use</I>, servidores da nuvem são
normalmente membros de um grupo variável de servidores configurados
de forma semelhante a execução de tarefas dinâmicas e escaláveis
relacionadas à computação paralela, <SPAN STYLE="background: #ffff00">mineração
de dados - </SPAN><I><SPAN STYLE="background: #ffff00">data mining</SPAN></I>
– ou servidores de páginas da web. Por <SPAN STYLE="background: #ff0000">'bootar'</SPAN>
repetidamente novas instâncias da mesma template estática,
servidores da nuvem comerciais deixam de cumprir a promessa de
computação sob demanda verdadeira (<SPAN STYLE="background: #ffff00">commercial
clouds fail to fully deliver on the promise of true on-demand
computation)</SPAN>. Após instanciar o servidor, o usuário da nuvem
deve continuar gerenciando os membros do <I>cluster</I> e intermediar
a adição de novos servidores.</FONT></FONT></P>
<P ALIGN=JUSTIFY><FONT COLOR="#000000"><FONT FACE="arial, sans-serif">SnowFlock
aborda estas questões com a clonagem de MVs, nossa proposta de
chamada a API da nuvem (<SPAN STYLE="background: #ffff00">our
proposed cloud API call</SPAN>). Do mesmo jeito que o código do
aplicativo rotineiramente invoca serviços do SO através de uma
interface <I>syscall</I>, poderia também agora invocar serviços na
nuvem através de uma interface similar. Com a clonagem de MVs
SnowFlock, a alocação de recursos, o gerenciamento de cluster e a
lógica da aplicação pode ser interligados de modo programável e
tratados como uma única operação lógica.</FONT></FONT></P>
<P ALIGN=JUSTIFY><FONT COLOR="#000000"><FONT FACE="arial, sans-serif">A
MV chamada clone instancia múltiplos servidores na nuvem que são
cópias idênticas a MV original até o ponto da clonagem.
Logicamente, os clones herdam todos os estados de seus pais,
incluindo SO – e <I>caches</I> de aplicativos. Além disso, clones
são automaticamente adicionados a uma rede interna privada, portanto
efetivamente ingressam em um <I>cluster</I> dinamicamente escalável.
Novos recursos computacionais, encapsulados como MV idênticas, podem
ser criados <I>on-the-fly</I> e podem ser dinamicamente <SPAN STYLE="background: #ffff00">alavancados</SPAN>
quando necessário.</FONT></FONT></P>
<P ALIGN=JUSTIFY><FONT COLOR="#000000"><FONT FACE="arial, sans-serif">Para
ser de uso prático, a clonagem de MV deve ser aplicável, eficiente
e rápida. Neste capítulo nós vamos descrever como a implementação
de SnowFlock na clonagem de MV pode ser efetivamente interligada em
diversos modelos de programas e <I>frameworks</I>, como isto pode ser
implementado para manter o tempo de execução de aplicativos e
prover sobrecarga mínima, e como isto pode ser usado para criar
dezenas de novas MV em cinco segundos ou menos.</FONT></FONT></P>
<P ALIGN=JUSTIFY><FONT COLOR="#000000"><FONT FACE="arial, sans-serif">Com
uma API para o controle programável da clonagem de MV com
vinculações em C, C++, Python e Java, SnowFlock é extremamente
flexível e versátil. Nós temos utilizado o SnowFlock com sucesso
em implementações de protótipos de vários sistemas bem
diferentes. Em cenários de computação paralela, nós temos
alcançado excelentes resultados pela explícita clonagem de MV em
produção que cooperativamente distribui a carga em muitos <I>hosts</I>
físicos. Para aplicativos paralelos que utilizam a interface de
troca de mensagem (Message Passing Interface – MPI, padrão para
comunicação de dados em computação paralela) e tipicamente
executam um <I>cluster</I> de servidores dedicados, nós modificamos
o gerenciamento de inicialização da MPI para fornecer aplicativos
inalterados com bom desempenho e muito menos sobrecarga por fornecer
um <I>cluster</I> novo de clones sob a demanda para cada execução.
Finalmente, em um caso de uso bem diferente, utilizamos o SnowFlock
para melhoar a eficiência e performance de servidores elásticos.
Hoje, os servidores elásticos baseados na nuvem possuem uma nova
inicialização, <SPAN STYLE="background: #ffff00">trabalhadores
frios</SPAN> como necessários para picos de demanda <SPAN STYLE="background: #ffff00">(Today's
cloud-based elastic servers boot new, cold workers as needed to
service spikes in demand.)</SPAN>. Em vez de clonar uma MV em
execução, SnowFlock traz novos <SPAN STYLE="background: #ffff00">trabalhadores</SPAN>
online 20 vezes mais rápido, e por herdarem o <SPAN STYLE="background: #ffff00">warm
buffer</SPAN><SPAN STYLE="background: #ffffff"> de seu pai, elas
atingem seu desempenho máximo mais rápido.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY><BR><BR>
</P>
<P ALIGN=JUSTIFY><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><FONT SIZE=4><I><SPAN STYLE="background: #ffffff">18.2
A clonagem de MV</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY><BR><BR>
</P>
<P ALIGN=JUSTIFY><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">Como
o nome sugere, os clones das MVs são (quase) idênticas a sua MV
pai. Existem na verdade algumas pequenas mas necessárias diferenças
para evitar questões tal como conflitos de endereço de MAC, mas nós
vamos voltar a isso depois. Para criar um clone, todo o disco local e
o estado da memória devem ser disponibilizados, o que nos traz para
o primeiro maior </SPAN><I><SPAN STYLE="background: #ffffff">design</SPAN></I><SPAN STYLE="background: #ffffff">
</SPAN><I><SPAN STYLE="background: #ffffff">tradeoff</SPAN></I><SPAN STYLE="background: #ffffff">
</SPAN><SPAN STYLE="font-style: normal"><SPAN STYLE="background: #ffffff">(expressão
que define uma situação em que há conflito de escolha): nós
devemos copiar o estado na frente ou sob demanda?</SPAN></SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="font-style: normal"><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">A
maneira mais simples de realizar a clonagem de MV é adaptar o padrão
MV de capacidade de migração<SPAN STYLE="background: #ffff00">(</SPAN><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffff00">to
adapt the standard VM &quot;migration&quot; capability)</SPAN></SPAN>.
Normalmente, a migração é usada quando a MV em execução precisa
ser movida para um <I>host </I>diferente, tal como quando o <I>host</I>
fica sobrecarregado ou deve ser desativado para manutenção. Devido
a MV ser meramente software, ela pode ser encapsulada em um arquivo
de dados que pode então ser copiado para um <I>host</I> novo e mais
apropriado, <SPAN STYLE="background: #ff0000">onde</SPAN> voltará
para execução após uma breve interrupção. Para efetuar isto, o
VMM cria externamente um arquivo contendo um <I>checkpoint</I> da MV,
incluindo o seu sistema de arquivos local, a imagem da memória, os
registros da CPU virtual (VCPU), etc. Na migração, a recém-iniciada
cópia substitui a original, mas o processo pode ser alterado para
produzir um clone deixando a original em execução. Neste processo
“impaciente”, o estado da MV inteira é transferido, o que provê
a melhor performance inicial, porque todo o estado da MV esta em
vigor quando a execução começa. A desvantagem da replicação
“impaciente” é que o penoso processo de copiar a MV inteira deve
acontecer antes da execução poder começar, o que deixa
significantemente mais lenta a instanciação.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="font-style: normal"><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">O
outro extremo, adotado pelo SnowFlock, é a replicação de estado
“preguiçosa”. Em vez de copiar tudo o que a MV pode precisar,
SnowFlock transfere somente as partes essenciais para iniciar a
execução, e transfere o estado depois, somente quando o clone
precisar. Isto possui duas vantagens. Primeiro, ele minimiza a
latência de instanciação fazendo o menor trabalho possível.
Segundo, ele aumenta a eficiência, copiando somente o estado que é
realmente utilizado pelo clone. O rendimento deste benefício, é
claro, depende do comportamento do clone, mas poucos aplicativos
acessam todas as páginas da memória e todos os arquivos no sistema
local de arquivos.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="font-style: normal"><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">No
entanto, os benefícios da replicação “preguiçosa” não são
livres. Como a transferência de estado é adiada até o último
momento, o clone deve aguardar pelo envio do estado antes de
continuar a execução. Esta situação de troca paralela de memória
para o disco em estações de trabalho de tempo compartilhado:
aplicativos são bloqueados esperando pelo estado a ser obtido a
partir de uma fonte de alta latência (<SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffff00">This
This situation parallels swapping of memory to disk in time-shared
workstation: applications are blocked waiting for state to be fetched
from a high latency source.)</SPAN></SPAN><SPAN STYLE="font-weight: normal">.
No caso do SnowFlock, o bloqueio degrada o desempenho do clone; a
gravidade da perda de desempenho depende do aplicação. Para
aplicações de computação de alto desempenho que nós encontramos,
esta degradação tem pouco impacto, mas um servidor de banco de
dados clonado pode funcionar mal a princípio. Deve-se notar que este
é um efeito transitório: em poucos minutos, a maior parte do estado
necessário foi transferido e o desempenho do clone corresponde ao do
pai.</SPAN></SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="font-style: normal"><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ff00ff">Como
um aparte(As an aside)</SPAN></SPAN><SPAN STYLE="font-weight: normal">,
se você esta acostumado (well versed in VMs) com MVs, é provável
que esteja perguntado se as otimizações utilizadas pela migração
“ao vivo” são úteis. A migração “ao vivo” é otimizada
para reduzir o intervalo entre a suspensão da MV original e a
retomada da execução da nova cópia. Para realizar isto, o Monitor
de Máquina Virtual (VMM) copia previamente o estado da MV, enquanto
a original continua em execução, então suspende a original,
somente as páginas alteradas recentemente precisam ser transferidas.
Esta técnica não afeta o intervalo entre a requisição de migração
e o tempo em que a cópia começa a ser executada, e assim não deve
reduzir a latência de instanciação da clonagem “impaciente” de
MV.</SPAN></SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="font-weight: normal; widows: 2; orphans: 2"><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><FONT SIZE=4><I><SPAN STYLE="background: #ffffff">18.3
A abordagem do SnowFlock (<SPAN STYLE="background: #94006b">SnowFlock's
Approach</SPAN>)</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="widows: 2; orphans: 2"><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">O
SnowFlock implementa a clonagem de MV com um primitivo chamado “<I>VM
Fork</I>”, que é como um “<I>Unix fork</I>” padrão, mas com
algumas diferenças importantes. Primeiramente, em vez de duplicar um
único processo, o <I>VM Fork</I> duplica uma MV inteira, incluindo
toda memória, todos os processos e dispositivos virtuais, e o
sistema de arquivos local. Em segundo lugar, ao invés de produzir
uma única cópia em execução no mesmo <I>host</I> físico, <I>VM
Fork</I> pode simultaneamente gerar muitas cópias em paralelo.
Finalmente, as MVs podem ser divididas em servidores físicos
distintos, permitindo-lhe aumentar rapidamente sua capacidade de
nuvem conforme necessário.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">Os
seguintes conceitos são fundamentais para o SnowFlock:</SPAN></FONT></FONT></P>
<UL>
	<LI><P ALIGN=JUSTIFY STYLE="font-style: normal; font-weight: normal; widows: 2; orphans: 2">
	<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">Virtualização:
	a MV encapsula o ambiente de computação, tornando “nuvens” e a
	clonagem de máquinas possível;</SPAN></FONT></FONT></P>
	<LI><P ALIGN=JUSTIFY STYLE="font-style: normal; font-weight: normal; widows: 2; orphans: 2">
	<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">Propagação
	“preguiçosa”: o estado da MV não é copiado até ser
	necessário, então os clones “ganham vida” em poucos segundos;</SPAN></FONT></FONT></P>
	<LI><P ALIGN=JUSTIFY STYLE="font-weight: normal; widows: 2; orphans: 2">
	<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><I><SPAN STYLE="background: #ffffff">Multicast</SPAN></I><SPAN STYLE="font-style: normal"><SPAN STYLE="background: #ffffff">:
	clones irmãos possuem necessidades similares em termos de estado de
	MV. Com o </SPAN></SPAN><I><SPAN STYLE="background: #ffffff">multicast</SPAN></I><SPAN STYLE="font-style: normal"><SPAN STYLE="background: #ffffff">,
	dezenas de clones começam a executar tão rápido quanto apenas um;</SPAN></SPAN></FONT></FONT></P>
	<LI><P ALIGN=JUSTIFY STYLE="font-style: normal; font-weight: normal; widows: 2; orphans: 2">
	<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">Falhas
	de página: quando um clone tenta utilizar uma memória inexistente,
	isto falha e dispara uma requisição para o pai. A execução do
	clone é bloqueada até a página necessária chegar;</SPAN></FONT></FONT></P>
	<LI><P ALIGN=JUSTIFY STYLE="widows: 2; orphans: 2"><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">Cópia
	na escrita (</SPAN></SPAN></SPAN><I><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">Copy
	on Write</SPAN></SPAN></I><SPAN STYLE="background: #ffffff"> –
	</SPAN><I><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">CoW</SPAN></SPAN></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">):
	tomando uma cópia de sua memória e páginas de disco antes de
	sobrescrevê-las, a MV pai pode continuar executando enquanto
	preserva uma cópia “congelada” deste estado para ser usado
	pelos clones.</SPAN></SPAN></SPAN></FONT></FONT></P>
</UL>
<P ALIGN=JUSTIFY STYLE="widows: 2; orphans: 2"><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">Nós
implementamos o SnowFlock utilizando o sistema de virtualização
Xen, então é útil introduzirmos alguns termos específicos do Xen
para que fiquem claros. Em um ambiente Xen, o VMM é chamado de
<I>hypervisor</I>, e as Mvs são chamadas de domínios. Em cada
máquina física (<I>host</I>), existe um domínio privilegiado,
chamado “domínio 0” (dom0), que tem acesso total ao <I>host</I>
e a seus dispositivos físicos, e pode ser utilizado para controlar
um convidado adicional, ou “usuário”, MVs que são chamadas
“domínio U” (domU).</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">De
modo geral, SnowFlock consiste de um conjunto de modificações no
<I>hypervisor</I> do Xen que o permitem recuperar sem problemas
quando os recursos em falta são acessados, e um conjunto de
processos de suporte e sistemas que são executados no dom0 e
cooperativamente transferem o estado da MV que falta, e algumas
modificações opcionais para o SO executar dentro de MVs clonadas.
Há 6 componentes principais.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">-
Descritor de MV </SPAN></SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffff00">(VM
Descriptor)</SPAN></SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">:
Este pequeno objeto é usado para semear o clone, e mantém o
esqueleto </SPAN></SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif">dos
bare-bones (<A HREF="http://en.wikipedia.org/wiki/Barebone_computer">http://en.wikipedia.org/wiki/Barebone_computer</A>
– colocar?) da MV como necessário para começar a execução.
Falta-lhe a coragem e o músculo necessário para realizar qualquer
trabalho útil;</FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="widows: 2; orphans: 2"><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">-
Sistema de Distribuição Multicast (</SPAN></SPAN></SPAN></FONT></FONT><CODE CLASS="western"><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">mcdist):
Este sistema do lado do pai distribui eficientemente as informações
de estado da MV simultaneamente para todos os clones;</SPAN></SPAN></SPAN></FONT></FONT></CODE></P>
<P ALIGN=JUSTIFY STYLE="font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">-
Processo de Servidor de Memória <SPAN STYLE="background: #ffff00">(Memory
Server Process)</SPAN>: Este processo do lado do pai mantém uma
cópia congelada do estado do pai, e torna disponível para todos os
clones sob demanda através do mcdist;</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">-
Processo <I>Memtap</I>: Este processo do lado do clone atua a favor
do clone, e se comunica com a o servidor de memória para solicitar
páginas que são necessárias mas estão faltando;</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">-
Iluminação do clone (<SPAN STYLE="background: #ffff00">Clone
Enlightenment</SPAN>): O <I>kernel</I> convidado em execução dentro
dos clones pode aliviar a transferência sob demanda de estado da MV,
fornecendo dicas para o VMM. Isto é opcional, mas altamente
desejável para eficiência;</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">-
Pilha de controle: <I>Daemons</I> são executados em cada <I>host</I>
físico para orquestrar os outros componentes e gerenciar o pai
SnowFlock e as MVs clonadas.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="widows: 2; orphans: 2"><BR><BR>
</P>
<P ALIGN=CENTER STYLE="widows: 2; orphans: 2"><BR><BR>
</P>
<UL>
	<P ALIGN=CENTER STYLE="margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
	<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #23ff23">FIGURA!</SPAN></FONT></FONT></P>
</UL>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">Figura
18.1: Arquitetura de replicação de MV SnowFlock.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; widows: 2; orphans: 2"><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">Pictoricamente
falando, a Figura 18.1 descreve o processo de clonagem de uma MV,
mostrando as 4 etapas principais: (1) interromper a MV pai para
produzir um descritor da arquitetura; (2) distribuir este descritor
para todos os <I>hosts</I> alvo; (3) iniciar os clones que são
estados sábios quase vazios (<SPAN STYLE="background: #ffff00">initiating
clones that are mostly empty state-wise</SPAN>); e (4) propagar o
estado sob demanda. A figura também mostra o uso de distribuição
<I>multicast</I> com mcdist, e busca evitar a iluminação através
de convidado(<SPAN STYLE="background: #ffff00">and fetch avoidance
via guest enlightenment</SPAN>).</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">Se
você esta interessado em experimentar o SnowFlock, ele esta
disponível de duas maneiras (</SPAN></SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #00ffff">it's
available in two flavors</SPAN></SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">).
A documentação e o código-fonte aberto para a pesquisa original do
SnowFlock da Universadade de Toronto estão disponíveis [1]. Se você
preferir obter a versão industrial para teste, uma licença livre e
não-comercial esta disponível no GridCentric Inc [2]. </SPAN></SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffff00">(The
documentation and open source code for the original University of
Toronto SnowFlock research project are available<A HREF="http://www.aosabook.org/en/snowflock.html#footnote-1">1</A>&nbsp;If
you'd prefer to take the industrial-strength version for a spin, a
free, non-commercial license is available from GridCentric Inc.<A HREF="http://www.aosabook.org/en/snowflock.html#footnote-2">2</A>)</SPAN></SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><SPAN STYLE="background: #ffffff">
</SPAN></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">Devido
ao SnowFlock incluir alterações ao </SPAN></SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><I><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">hypervisor</SPAN></SPAN></I></FONT></FONT><FONT COLOR="#000000"><SPAN STYLE="background: #ffffff">
</SPAN></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">e
requerer acesso ao dom0, instala-lo requer acesso privilegiado nas
máquinas de </SPAN></SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><I><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">host</SPAN></SPAN></I></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">.
Por esta razão, você precisará usar seu próprio </SPAN></SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><I><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">hardware</SPAN></SPAN></I></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">,
e não estará apto a experimentá-lo fora como um usuário num
ambiente comercial de nuvem tal como o EC2 da Amazon.</SPAN></SPAN></SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">Ao
longo das próximas seções nós descreveremos as diferentes partes
que cooperam para atingir clonagens instantâneas e eficientes. Todos
os pedaços que se encaixam nós descreveremos, como mostrado na
Figura 18.2.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #23ff23">FIGURA!</SPAN></FONT></FONT></P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">Figura
18.2: Componentes de Software do SnowFlock.</SPAN></FONT></FONT></P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<H2 CLASS="western" ALIGN=JUSTIFY STYLE="margin-top: 0cm; margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><FONT SIZE=4><SPAN STYLE="background: #ffffff">18.4
Descritor Arquitetural da MV (Architectural VM Descriptor)</SPAN></FONT></FONT></FONT></H2>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif">O decisão-chave
de design para o SnowFlock é adiar a replicação de estado da MV
para uma operação de tempo de execução “preguiçosa”. Em
outras palavras, copiar a memória de uma MV é uma operação de
ligação tardia, permitindo muitas oportunidades de otimização.</FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif">O primeiro passo
para realizar esta decisão de design é a geração de um descritor
de arquitetura do estado da MV. Esta é a semente que será usada
para criar as MVs clonadas. Ela contém o mínimo necessário para
criar uma MV e torná-la escalonável (</FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffff00">schedulable</SPAN></SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">).
Como o nome indica, este mínimo é composto por estruturas de dados
necessários para </SPAN></SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><FONT SIZE=3><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">a
especificação básica de arquitetura. No caso do SnowFlock, a
arquitetura é uma combinação de requisitos do processador Intel
x86 e os requisitos do Xen. O descritor de arquitetura, portanto,
contém estruturas de dados tal como tabelas de páginas, registros
virtuais, dispositivos de metadados, </SPAN></SPAN></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><FONT SIZE=3><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffff00">wallclock
timestamps</SPAN></SPAN></SPAN></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><FONT SIZE=3><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ffffff">,
etc. Nós encaminhamos o leitor interessado para [<A HREF="http://www.aosabook.org/en/bibliography.html#bib:snowflock:tocs">LCWB+11</A>],
para uma descrição detalhada dos conteúdos do descritor de
arquitetura.</SPAN></SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif">Um descritor de
arquitetura possui três propriedades importantes: Primeiro, ele pode
ser criado em pouco tempo; 200 milissegundo não é incomum. Segundo,
ele é pequeno, tipicamente três ordens de magnitude menores que a
alocação de memória da MV de origem (1 MB para 1 GB de MV). E
terceiro, uma MV clone pode ser criada a partir de um descritor em
menos de um segundo (normalmente 800 milissegundos).</FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif">O problema, com
certeza, é que as MVs clonadas perdem a maior parte de seu estado de
memória no momento em que são criadas a partir do descritor. A
seções seguintes explicam como nós resolvemos este problema – e
como aproveitamos as oportunidades de otimização apresentadas.</FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<H2 CLASS="western"><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><FONT SIZE=4><SPAN STYLE="font-weight: normal">18.5
Componentes do lado-pai </SPAN><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">(18.5.
Parent-Side Components)</SPAN></SPAN></FONT></FONT></FONT></H2>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif">Uma vez que a MV
é clonada ela se torna um pai para seus filhos ou clones. Como todos
os pais responsáveis, ela precisa vigiar pelo bem-estar de seus
descendentes. Isso se dá pela criação de um conjunto de serviços
que fornecem memória e estado de disco para a MVs clonadas sob
demanda.</FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif">18.5.1 Processo
<I>Memsever</I> (<SPAN STYLE="background: #ffff00">servir memória</SPAN>)</FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif">Quando o
descritor de arquitetura é criado, a MV é interrompida em suas
faixas ao longo do processo. Assim o estado da memória da MV é
resolvido; antes de realmente pausar uma MV e desindexar da execução,
controladores internos quiesce – pausa ou alteração do estado de
processos em execução no computador - do SO em um estado do qual os
clones podem reconectar para o mundo externo em suas novas MVs
anexadas. Aproveitamos este estado quiesce para criar um “servidor
de memória”, ou memserver.</FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ff0000">(When
the architectural descriptor is created, the VM is stopped in its
tracks throughout the process. This is so the VM memory state
settles; before actually pausing a VM and descheduling from
execution, internal OS drivers quiesce into a state from which clones
can reconnect to the external world in their new enclosing VMs. We
take advantage of this quiescent state to create a &quot;memory
server&quot;, or&nbsp;</SPAN></SPAN></SPAN></FONT></FONT><CODE CLASS="western"><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ff0000">memserver</SPAN></SPAN></SPAN></FONT></FONT></CODE><FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ff0000">.)</SPAN></SPAN></SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="background: #ffffff">O
servidor de memória irá fornecer todos os clones com os bits de
memória que eles precisem dos pais. A memória é propagada para
granularidade de uma página de memória x86 (4kbytes). Em sua forma
mais simples, o servidor de memória fica à espera de pedidos de
página a partir dos clones, e serve uma página por vez, um clone
por vez.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif">Todavia, esta é
a mesma memória que a MV pai necessita usar para se manter em
execução. Se permitíssemos o pai ir em frente e modificar esta
memória, nós serviríamos conteúdo de memória corrompido para
clonar as MVs: a memória servida seria diferente da que no momento
da clonagem, e os clones seriam confundidos <SPAN STYLE="background: #ff0000">(</SPAN><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: #ff0000">would
be mightily confused</SPAN></SPAN></SPAN><SPAN STYLE="background: #ff0000">)</SPAN>.
Em termos de kernel hacking, esta é uma receita certa para
rastreamentos de pilha.</FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif">Para contornar
este problema, uma noção clássica de SO veio para a salvação:
<I>Copy-on-Write</I> <SPAN STYLE="font-style: normal">(</SPAN>cópia
na escrita), ou memória <I>CoW</I><SPAN STYLE="font-style: normal">.
Ao buscar ajuda do </SPAN><I>Xen hypervisor</I><SPAN STYLE="font-style: normal">,
nós podemos remover privilégios de escrita de todas as páginas de
memória na MV pai. Quando o pai realmente tenta modificar uma
página, uma falha de página de hardware é acionado. O Xen sabe por
que isto aconteceu, e faz uma cópia da página. A MV pai é
permitido escrever na página original e continuar em execução,
enquanto o servidor de memória é avisado para usar a cópia, que é
mantida em somente leitura. Desta maneira, o estado de memória no
ponto de clonagem permanece congelado para que o clone não seja
confundido, enquanto o pai é habilitado para prosseguir com a
execução. A sobrecarga de CoW é mínima: mecanismos similares são
usados pelo Linux, por exemplo, quando novos processos são criados.</SPAN></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><SPAN STYLE="font-style: normal">18.5.2
</SPAN><FONT FACE="sans-serif"><I><SPAN STYLE="font-weight: normal">Multicasting</SPAN></I></FONT><FONT FACE="sans-serif"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">
com</SPAN></SPAN></FONT><FONT FACE="sans-serif"><I><SPAN STYLE="font-weight: normal">
Mcdist</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="arial, sans-serif"><FONT FACE="sans-serif"><SPAN STYLE="font-weight: normal">	Os
clones são tipicamente aflitos com uma síndrome existencial
conhecida como “destino determinista”(</SPAN></FONT><FONT FACE="sans-serif"><I><SPAN STYLE="font-weight: normal">fate
determinism</SPAN></I></FONT><FONT FACE="sans-serif"><SPAN STYLE="font-weight: normal">).
Esperamos os clones a serem criados para uma única finalidade: por
exemplo, para alinhar cadeias X de DNA com um segmento Y de um banco
de dados. Além disso, nós esperamos um conjunto de clones a serem
criados para que todos os irmãos façam o mesmo, talvez alinhem as
mesmas cadeias X com diferentes segmentos do banco de dados, ou
alinhem diferentes cadeias com o mesmo seguimento Y. Os clones,
assim, claramente exibem uma grande quantidade de localidade temporal
em seus acessos de memória: eles usarão o mesmo código e grandes
porções de dados comuns.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="sans-serif"><I>	</I></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; border: none; padding: 0cm; font-style: normal; font-weight: normal; widows: 2; orphans: 2">
<FONT COLOR="#000000"><FONT FACE="sans-serif">We exploit the
opportunities for temporal locality through&nbsp;<CODE CLASS="western"><FONT FACE="sans-serif">mcdist</FONT></CODE>,
our own multicast distribution system tailored to SnowFlock. Mcdist
uses IP multicast to simultaneously distribute the same packet to a
set of receivers. It takes advantage of network hardware parallelism
to decrease the load on the memory server. By sending a reply to all
clones on the first request for a page, each clone's requests act as
a prefetch for its siblings, because of their similar memory access
patterns.</FONT></FONT></P>
</BODY>
</HTML>